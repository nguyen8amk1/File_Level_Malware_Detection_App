import numpy as np
import torch
from torch.utils.data import Dataset
from pandas import read_csv
import pandas as pd 
from os import path 
import csv


def write_pred(test_pred,test_idx,file_path):
    test_pred = [item for sublist in test_pred for item in sublist]
    with open(file_path,'w') as f:
        for idx,pred in zip(test_idx,test_pred):
            print(idx.upper()+','+str(pred[0]),file=f)

# Dataset preparation
class ExeDataset(Dataset):
    def __init__(self, fp_list, data_path, label_list, first_n_byte=2000000):
        self.fp_list = fp_list
        self.data_path = data_path
        self.label_list = label_list
        self.first_n_byte = first_n_byte

    def __len__(self):
        return len(self.fp_list)

    def __getitem__(self, idx):
        try:
            with open(self.data_path+self.fp_list[idx],'rb') as f:
                tmp = [i+1 for i in f.read()[:self.first_n_byte]]
                tmp = tmp+[0]*(self.first_n_byte-len(tmp))
        except:
            with open(self.data_path+self.fp_list[idx].lower(),'rb') as f:
                tmp = [i+1 for i in f.read()[:self.first_n_byte]]
                tmp = tmp+[0]*(self.first_n_byte-len(tmp))

        return np.array(tmp),np.array([self.label_list[idx]])

class OLEDataset(Dataset):
    def __init__(self, csv_file):
        # 1. data loading 
        #d = np.loadtxt(csv_file, delimiter=",", dtype=np.int64)
        #self.streams_and_labels = d.fillna(0).astype("int64").value
        d = read_csv(csv_file)
        xy = d.fillna(0).astype("int64").values
        # self.X = torch.from_numpy(xy[:, 1:])
        # self.y = torch.from_numpy(xy[:, [0]])
        self.X = xy[:, 1:]
        self.y = xy[:, [0]].astype(np.float32)

        self.n_samples = xy.shape[0];

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

    def __len__(self):
        return self.n_samples

class FileLevelOLEDataset(Dataset):
    def __init__(self, data_path, base_path, csv_file_list):
        # 1. data loading 
        #d = np.loadtxt(csv_file, delimiter=",", dtype=np.int64)
        #self.streams_and_labels = d.fillna(0).astype("int64").value

        # TODO: what self.X, self.y should be
        # self.X[idx] = [stream1, stream2, stream3,...]
        # stream1 = [1231,2321312,321,3213]
        # self.Y[idx] = [label1, label2, label3]
        # label1 = [0]
        self.X = []
        self.y = []
        count = 0

        with open(path.join(base_path, csv_file_list), 'r') as csvfilelist:
            datareader = csv.reader(csvfilelist)
            for row in datareader:
                csv_file = row[0]
                file_path = path.join(data_path, csv_file)
                print(file_path)
                d = None
                try:
                    d = read_csv(file_path)
                except:
                    print(f"Failed to read {csv_file}")
                    continue
                    
                #d = np.loadtxt(csv_file, delimiter=",", dtype=np.int64)
                #self.streams_and_labels = d.fillna(0).astype("int64").value
                # d = np.genfromtxt(file_path, delimiter=",", dtype=np.float64, filling_values=0)
                #
                # df = pd.DataFrame(d)
                #
                # df = df.fillna(0).astype(np.int64)
                #
                # xy = df.to_numpy()
                if(len(d) <= 0): 
                    #print(f"What the fuck is happening {row[0]}: \n {d}")
                    continue
                # else: 
                #     print(f"This is a good dataframe {row[0]}: \n {d}")
                    

                # if(len(d) < 0): 
                #     #print(d, len(d))
                #     xy = d.fillna(0).astype("int64").values
                #     print(xy)

                xy = d.fillna(0).astype("int64").values
                #xy = d.fillna(0).astype("float64").values
                # self.X = torch.from_numpy(xy[:, 1:])
                # self.y = torch.from_numpy(xy[:, [0]])
                self.X.append(xy[:, 1:])
                #self.y.append(xy[:, [0]].astype(np.float32))
                # TODO: return a tensor that looks like this tensor([[-0.0109]] 
                y_value = float(row[1])  # Convert the string to a float
                self.y.append([y_value])  # Append the float as a list
                #self.y.append(row[1])
                # count+=1
                # if(count > 5000): 
                #     break

        self.y = np.array(self.y)
        self.n_samples = len(self.X);

    def __getitem__(self, idx):
        if(len(self.X[idx]) < 0): 
            print(f"What the fuck is happening: \n {self.X[idx]}")
            
        return self.X[idx], self.y[idx]

    def __len__(self):
        return self.n_samples
