import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F

class Mf(nn.Module):
    def __init__(self): 
        super(Mf, self).__init__()

        self.fc_1 = nn.Linear(128,128)
        self.fc_2 = nn.Linear(128,1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.fc_1(x)
        x = self.fc_2(x)
        #x = self.sigmoid(x)
        return x

class Ms(nn.Module): 
    def __init__(self,input_length=2000000,window_size=500):
        super(Ms, self).__init__()

        self.embed = nn.Embedding(257, 8, padding_idx=0)

        self.conv_1 = nn.Conv1d(4, 128, window_size, stride=window_size, bias=True)
        self.conv_2 = nn.Conv1d(4, 128, window_size, stride=window_size, bias=True)

        self.pooling = nn.MaxPool1d(int(input_length/window_size))
        

        self.fc_1 = nn.Linear(128,128)
        self.fc_2 = nn.Linear(128,1)

        self.sigmoid = nn.Sigmoid()
        #self.softmax = nn.Softmax()
        

    def forward(self,x):
        x = self.embed(x)
        # Channel first
        x = torch.transpose(x,-1,-2)

        cnn_value = self.conv_1(x.narrow(-2, 0, 4))
        gating_weight = self.sigmoid(self.conv_2(x.narrow(-2, 4, 4)))

        x = cnn_value * gating_weight
        x = self.pooling(x)

        x = x.view(-1,128)

        # x = self.fc_1(x)
        # x = self.fc_2(x)
        #x = self.sigmoid(x)

        return x

def favg(streams):
    # Convert the list of streams to a NumPy array for easier element-wise operations
    # streams_array = np.array(streams)
    streams_array = np.array([stream.detach().numpy() for stream in streams])

    # Calculate the sum of all streams element-wise
    total_stream = np.sum(streams_array, axis=0)
    
    # Calculate the average by dividing the total by the number of streams
    average_stream = total_stream / len(streams)
    
    # return average_stream
    return torch.tensor(average_stream, dtype=torch.float32)

def fmin(streams):
    # Convert the list of streams to a NumPy array for easier element-wise operations
    streams_array = np.array([stream.detach().numpy() for stream in streams])

    # Calculate the minimum of all streams element-wise
    min_stream = np.min(streams_array, axis=0)
    
    return torch.tensor(min_stream, dtype=torch.float32)

def fmax(streams):
    # Convert the list of streams to a NumPy array for easier element-wise operations
    streams_array = np.array([stream.detach().numpy() for stream in streams])

    # Calculate the maximum of all streams element-wise
    max_stream = np.max(streams_array, axis=0)
    
    return torch.tensor(max_stream, dtype=torch.float32)


# TODO: the input of this model should be a "file"
# meaning x[i] = an array of streams, not a single stream  
class FileLevelModel(nn.Module):
    def __init__(self, input_length=2000000, window_size=500):
        super(FileLevelModel, self).__init__()
        self.ms = Ms(input_length, window_size)
        self.mf = Mf()

    # This x is gonna be: the an array of streams, the output should be 
    def forward(self, x):
        streams = []
        x = x.squeeze(0)
        #print("Machine learning: ", x_resized)
        for stream in x: 
            streams.append(self.ms(stream))
        #x = favg(streams)
        x = fmin(streams)
        #x = fmax(streams)
        x = self.mf(x)
        return x





















class MalConv(nn.Module):
    def __init__(self,input_length=2000000,window_size=500):
        super(MalConv, self).__init__()

        self.embed = nn.Embedding(257, 8, padding_idx=0)

        self.conv_1 = nn.Conv1d(4, 128, window_size, stride=window_size, bias=True)
        self.conv_2 = nn.Conv1d(4, 128, window_size, stride=window_size, bias=True)

        self.pooling = nn.MaxPool1d(int(input_length/window_size))
        

        self.fc_1 = nn.Linear(128,128)
        self.fc_2 = nn.Linear(128,1)

        self.sigmoid = nn.Sigmoid()
        #self.softmax = nn.Softmax()
        

    def forward(self,x):
        x = self.embed(x)
        # Channel first
        x = torch.transpose(x,-1,-2)

        cnn_value = self.conv_1(x.narrow(-2, 0, 4))
        gating_weight = self.sigmoid(self.conv_2(x.narrow(-2, 4, 4)))

        x = cnn_value * gating_weight
        x = self.pooling(x)

        x = x.view(-1,128)

        x = self.fc_1(x)
        x = self.fc_2(x)
        #x = self.sigmoid(x)

        return x
