from flask import Flask, request, render_template, jsonify
from flask_cors import CORS
from model import MalConv, FileLevelModel
import olefile
import torch

# test url: curl -X POST -F "file=@excel_test1.xls" http://127.0.0.1:5000/upload 
app = Flask(__name__)
CORS(app)

model = FileLevelModel(1018, 500)
model.load_state_dict(torch.load('../ole_model.pth'))
#model = torch.load('../checkpoint/example_sd_13.model')
model.eval()

@app.route('/')
def upload_form():
    return render_template('upload_form.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    uploaded_file = request.files['file']
    if uploaded_file.filename != '':
        uploaded_file.save(uploaded_file.filename)
        # Read the uploaded file as a stream
        file_stream = uploaded_file.stream

        # Use olefile to parse the OLE file stream
        ole = olefile.OleFileIO(file_stream)

        entries = ole.listdir(streams=True, storages=True)
        rows = []
        for entry in entries:
            # Print the entry path
            entry_path = '/'.join(entry)
            # Write label as the first column of the CSV file
            # Determine if it's a stream or a storage
            if ole.exists(entry):
                if ole.get_type(entry) == olefile.STGTY_STREAM:
                    content = ole.openstream(entry).read()

                    # Process the content into rows of 1018 columns
                    start = 0
                    magic_num = 1018
                    while start < len(content):
                        chunk = content[start:start + magic_num]  # 1017 because the first column is the label
                        if len(chunk) < magic_num:
                            chunk = chunk + b'\x00' * (magic_num - len(chunk))  # Pad with zeros

                        # Write the row with the label and chunk content
                        row = list(chunk)
                        rows.append(row)
                        #csv_writer.writerow(row)
                        start += magic_num

        streams = torch.tensor([rows])
        print(streams)

        def round_prediction(prediction): 
            rounded_value = round(prediction.item())
            return rounded_value

        with torch.no_grad(): 
            pred = model(streams)
            corrected_prediction = round_prediction(pred)
            print(f"Prediction: {pred}, Corrected Prediction: {corrected_prediction}")
            print(f"Prediction: {pred}")

        result = {'file_state': corrected_prediction}
        return jsonify(result)
    else:
        return 'No file selected'

if __name__ == '__main__':
    app.run(debug=True)

